// code-repository/src/portrait/portrait-export-manager.js
class PortraitExportManager {
  constructor() {
    this.exportFormats = ['svg', 'png', 'jpeg', 'pdf'];
    this.exportHistory = [];
    this.maxHistorySize = 10;
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) return;

    // Initialize export capabilities
    this.checkExportCapabilities();

    this.initialized = true;
    console.log('✅ PortraitExportManager initialized successfully');
  }

  checkExportCapabilities() {
    this.capabilities = {
      svg: true, // Always supported
      png: this.checkCanvasSupport(),
      jpeg: this.checkCanvasSupport(),
      pdf: this.checkPDFSupport()
    };
  }

  checkCanvasSupport() {
    try {
      const canvas = document.createElement('canvas');
      return !!(canvas.getContext && canvas.getContext('2d'));
    } catch (e) {
      return false;
    }
  }

  checkPDFSupport() {
    // Check for PDF generation libraries or native support
    return typeof window !== 'undefined' && (window.jsPDF || window.PDFLib);
  }

  async exportPortrait(portrait, format, options = {}) {
    if (!this.initialized) await this.initialize();

    if (!this.capabilities[format]) {
      throw new ExportError(`Export format '${format}' is not supported`);
    }

    try {
      let result;

      switch (format) {
        case 'svg':
          result = await this.exportToSVG(portrait, options);
          break;
        case 'png':
          result = await this.exportToPNG(portrait, options);
          break;
        case 'jpeg':
          result = await this.exportToJPEG(portrait, options);
          break;
        case 'pdf':
          result = await this.exportToPDF(portrait, options);
          break;
        default:
          throw new ExportError(`Unknown export format: ${format}`);
      }

      // Record export in history
      this.recordExport(format, options);

      console.log(`✅ Portrait exported successfully as ${format.toUpperCase()}`);
      return result;

    } catch (error) {
      console.error(`❌ Portrait export failed for format ${format}:`, error);
      throw new ExportError(error.message);
    }
  }

  async exportToSVG(portrait, options = {}) {
    const {
      width = 200,
      height = 300,
      includeMetadata = true,
      prettyPrint = false
    } = options;

    let svgContent = `<?xml version="1.0" encoding="UTF-8"?>${prettyPrint ? '\n' : ''}`;

    if (includeMetadata) {
      svgContent += `<!-- Generated by RulzLawyer Portrait Designer -->
<!-- Created: ${new Date().toISOString()} -->
${prettyPrint ? '\n' : ''}`;
    }

    svgContent += `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">${prettyPrint ? '\n' : ''}`;

    // Add portrait content (simplified - in real implementation would parse portrait object)
    if (typeof portrait === 'string' && portrait.includes('<svg')) {
      // If portrait is already SVG, extract content
      const contentMatch = portrait.match(/<svg[^>]*>([\s\S]*?)<\/svg>/);
      if (contentMatch) {
        svgContent += contentMatch[1];
      }
    } else {
      // Generate basic SVG content
      svgContent += this.generateBasicSVGContent(width, height);
    }

    svgContent += `${prettyPrint ? '\n' : ''}</svg>`;

    return {
      data: svgContent,
      mimeType: 'image/svg+xml',
      filename: `portrait-${Date.now()}.svg`
    };
  }

  async exportToPNG(portrait, options = {}) {
    const { width = 400, height = 600, quality = 1.0 } = options;

    // Create canvas for PNG export
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    // Fill background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, width, height);

    // Add placeholder content
    ctx.fillStyle = '#333';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Portrait PNG Export', width / 2, height / 2 - 20);
    ctx.fillText('(Implementation in Progress)', width / 2, height / 2 + 20);

    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve({
            data: blob,
            mimeType: 'image/png',
            filename: `portrait-${Date.now()}.png`
          });
        } else {
          reject(new ExportError('Failed to generate PNG blob'));
        }
      }, 'image/png', quality);
    });
  }

  async exportToJPEG(portrait, options = {}) {
    const { width = 400, height = 600, quality = 0.9 } = options;

    // Create canvas for JPEG export
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    // Fill background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, width, height);

    // Add placeholder content
    ctx.fillStyle = '#333';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Portrait JPEG Export', width / 2, height / 2 - 20);
    ctx.fillText('(Implementation in Progress)', width / 2, height / 2 + 20);

    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve({
            data: blob,
            mimeType: 'image/jpeg',
            filename: `portrait-${Date.now()}.jpg`
          });
        } else {
          reject(new ExportError('Failed to generate JPEG blob'));
        }
      }, 'image/jpeg', quality);
    });
  }

  async exportToPDF(portrait, options = {}) {
    const { width = 200, height = 300, title = 'Character Portrait' } = options;

    if (!this.checkPDFSupport()) {
      throw new ExportError('PDF export requires jsPDF library');
    }

    try {
      const { jsPDF } = window;
      const pdf = new jsPDF({
        orientation: width > height ? 'landscape' : 'portrait',
        unit: 'mm',
        format: [width * 0.264583, height * 0.264583] // Convert pixels to mm
      });

      // Add title
      pdf.setFontSize(16);
      pdf.text(title, 10, 20);

      // Add portrait information
      pdf.setFontSize(12);
      pdf.text('Generated by RulzLawyer Portrait Designer', 10, 35);
      pdf.text(`Created: ${new Date().toLocaleDateString()}`, 10, 45);

      // Add placeholder for portrait image
      pdf.setFontSize(10);
      pdf.text('(Portrait image integration pending)', 10, 60);

      return {
        data: pdf.output('blob'),
        mimeType: 'application/pdf',
        filename: `portrait-${Date.now()}.pdf`
      };

    } catch (error) {
      throw new ExportError(`PDF generation failed: ${error.message}`);
    }
  }

  generateBasicSVGContent(width, height) {
    return `
  <defs>
    <linearGradient id="skinGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#DEB887;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#D2B48C;stop-opacity:1" />
    </linearGradient>
  </defs>

  <!-- Background -->
  <rect width="${width}" height="${height}" fill="#f0f0f0"/>

  <!-- Body -->
  <ellipse cx="${width/2}" cy="${height * 0.6}" rx="${width * 0.25}" ry="${height * 0.3}" fill="url(#skinGradient)" stroke="#8B7355" stroke-width="2"/>

  <!-- Head -->
  <circle cx="${width/2}" cy="${height * 0.35}" r="${width * 0.15}" fill="url(#skinGradient)" stroke="#8B7355" stroke-width="2"/>

  <!-- Eyes -->
  <circle cx="${width * 0.45}" cy="${height * 0.32}" r="3" fill="#4169E1"/>
  <circle cx="${width * 0.55}" cy="${height * 0.32}" r="3" fill="#4169E1"/>

  <!-- Placeholder text -->
  <text x="${width/2}" y="${height * 0.8}" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">
    Portrait Preview
  </text>
  <text x="${width/2}" y="${height * 0.85}" text-anchor="middle" font-family="Arial" font-size="10" fill="#999">
    (SVG Generation Active)
  </text>
`;
  }

  async exportBatch(portraits, format, options = {}) {
    const results = [];

    for (const portrait of portraits) {
      try {
        const result = await this.exportPortrait(portrait, format, options);
        results.push(result);
      } catch (error) {
        console.error(`Failed to export portrait in batch:`, error);
        results.push({ error: error.message });
      }
    }

    return results;
  }

  recordExport(format, options) {
    const exportRecord = {
      timestamp: new Date(),
      format: format,
      options: options
    };

    this.exportHistory.push(exportRecord);

    // Maintain history size limit
    if (this.exportHistory.length > this.maxHistorySize) {
      this.exportHistory.shift();
    }
  }

  getExportHistory() {
    return [...this.exportHistory];
  }

  clearExportHistory() {
    this.exportHistory = [];
  }

  getSupportedFormats() {
    return Object.entries(this.capabilities)
      .filter(([format, supported]) => supported)
      .map(([format]) => format);
  }

  async validateExportOptions(format, options) {
    const formatValidators = {
      svg: this.validateSVGOptions,
      png: this.validateImageOptions,
      jpeg: this.validateImageOptions,
      pdf: this.validatePDFOptions
    };

    const validator = formatValidators[format];
    if (validator) {
      return await validator(options);
    }

    return { valid: true, errors: [] };
  }

  validateSVGOptions(options) {
    const errors = [];

    if (options.width && (options.width < 50 || options.width > 2000)) {
      errors.push('SVG width must be between 50 and 2000 pixels');
    }

    if (options.height && (options.height < 50 || options.height > 2000)) {
      errors.push('SVG height must be between 50 and 2000 pixels');
    }

    return { valid: errors.length === 0, errors };
  }

  validateImageOptions(options) {
    const errors = [];

    if (options.width && (options.width < 100 || options.width > 4000)) {
      errors.push('Image width must be between 100 and 4000 pixels');
    }

    if (options.height && (options.height < 100 || options.height > 4000)) {
      errors.push('Image height must be between 100 and 4000 pixels');
    }

    if (options.quality && (options.quality < 0.1 || options.quality > 1.0)) {
      errors.push('Quality must be between 0.1 and 1.0');
    }

    return { valid: errors.length === 0, errors };
  }

  validatePDFOptions(options) {
    const errors = [];

    if (options.title && options.title.length > 100) {
      errors.push('PDF title must be 100 characters or less');
    }

    return { valid: errors.length === 0, errors };
  }
}

// Error Classes
class ExportError extends Error {
  constructor(message) { super(message); this.name = 'ExportError'; }
}

// Browser/Node.js compatibility exports
if (typeof module !== 'undefined' && module.exports) {
  module.exports = PortraitExportManager;
} else if (typeof window !== 'undefined') {
  window.PortraitExportManager = PortraitExportManager;
}